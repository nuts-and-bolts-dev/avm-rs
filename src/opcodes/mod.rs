//! Opcode definitions and specifications

use crate::error::AvmResult;
use crate::types::RunMode;
use crate::vm::EvalContext;
use std::collections::HashSet;

pub mod argument;
pub mod arithmetic;
pub mod box_storage;
pub mod bytes;
pub mod constant;
pub mod crypto;
pub mod data;
pub mod elliptic_curve;
pub mod flow;
pub mod function;
pub mod inner_transaction;
pub mod stack;
pub mod state;
pub mod transaction;

pub use argument::*;
pub use arithmetic::*;
pub use box_storage::*;
pub use bytes::*;
pub use constant::*;
pub use crypto::*;
pub use data::*;
pub use elliptic_curve::*;
pub use flow::*;
pub use function::*;
pub use inner_transaction::*;
pub use stack::*;
pub use state::*;
pub use transaction::*;

/// Opcode execution function type
pub type OpcodeExecutor = fn(&mut EvalContext) -> AvmResult<()>;

/// Opcode specification
#[derive(Debug, Clone)]
pub struct OpSpec {
    /// Opcode byte value
    pub opcode: u8,
    /// Opcode name
    pub name: String,
    /// Execution function
    pub execute: OpcodeExecutor,
    /// Allowed run modes
    pub modes: HashSet<RunMode>,
    /// Minimum TEAL version required
    pub min_version: u8,
    /// Execution cost
    pub cost: u64,
    /// Size in bytes (including immediate values)
    pub size: usize,
    /// Human-readable description
    pub description: String,
}

impl OpSpec {
    /// Create a new opcode specification
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        opcode: u8,
        name: impl Into<String>,
        execute: OpcodeExecutor,
        modes: &[RunMode],
        min_version: u8,
        cost: u64,
        size: usize,
        description: impl Into<String>,
    ) -> Self {
        Self {
            opcode,
            name: name.into(),
            execute,
            modes: modes.iter().cloned().collect(),
            min_version,
            cost,
            size,
            description: description.into(),
        }
    }

    /// Create a specification for an opcode available in both modes
    pub fn both_modes(
        opcode: u8,
        name: impl Into<String>,
        execute: OpcodeExecutor,
        min_version: u8,
        cost: u64,
        size: usize,
        description: impl Into<String>,
    ) -> Self {
        Self::new(
            opcode,
            name,
            execute,
            &[RunMode::Signature, RunMode::Application],
            min_version,
            cost,
            size,
            description,
        )
    }

    /// Create a specification for an opcode available only in application mode
    pub fn app_only(
        opcode: u8,
        name: impl Into<String>,
        execute: OpcodeExecutor,
        min_version: u8,
        cost: u64,
        size: usize,
        description: impl Into<String>,
    ) -> Self {
        Self::new(
            opcode,
            name,
            execute,
            &[RunMode::Application],
            min_version,
            cost,
            size,
            description,
        )
    }
}

/// Get all standard opcode specifications
pub fn get_standard_opcodes() -> Vec<OpSpec> {
    vec![
        // Error
        OpSpec::both_modes(OP_ERR, "err", op_err, 1, 1, 1, "Error. Panic immediately."),
        // Arithmetic
        OpSpec::both_modes(
            OP_PLUS,
            "+",
            op_plus,
            1,
            1,
            1,
            "A plus B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_MINUS,
            "-",
            op_minus,
            1,
            1,
            1,
            "A minus B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_DIV,
            "/",
            op_div,
            1,
            1,
            1,
            "A divided by B. A and B are zero-terminated big-endian integers. Fail if B is zero.",
        ),
        OpSpec::both_modes(
            OP_MUL,
            "*",
            op_mul,
            1,
            1,
            1,
            "A times B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_LT,
            "<",
            op_lt,
            1,
            1,
            1,
            "A less than B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_GT,
            ">",
            op_gt,
            1,
            1,
            1,
            "A greater than B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_LE,
            "<=",
            op_le,
            1,
            1,
            1,
            "A less than or equal to B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_GE,
            ">=",
            op_ge,
            1,
            1,
            1,
            "A greater than or equal to B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_AND,
            "&&",
            op_and,
            1,
            1,
            1,
            "A is not zero and B is not zero.",
        ),
        OpSpec::both_modes(
            OP_OR,
            "||",
            op_or,
            1,
            1,
            1,
            "A is not zero or B is not zero.",
        ),
        OpSpec::both_modes(OP_EQ, "==", op_eq, 1, 1, 1, "A is equal to B."),
        OpSpec::both_modes(OP_NE, "!=", op_ne, 1, 1, 1, "A is not equal to B."),
        OpSpec::both_modes(OP_NOT, "!", op_not, 1, 1, 1, "A is zero."),
        OpSpec::both_modes(
            OP_MOD,
            "%",
            op_mod,
            1,
            1,
            1,
            "A modulo B. A and B are zero-terminated big-endian integers. Fail if B is zero.",
        ),
        OpSpec::both_modes(
            OP_BITWISE_OR,
            "|",
            op_bitwise_or,
            1,
            1,
            1,
            "A bitwise-or B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_BITWISE_AND,
            "&",
            op_bitwise_and,
            1,
            1,
            1,
            "A bitwise-and B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_BITWISE_XOR,
            "^",
            op_bitwise_xor,
            1,
            1,
            1,
            "A bitwise-xor B. A and B are zero-terminated big-endian integers.",
        ),
        OpSpec::both_modes(
            OP_BITWISE_NOT,
            "~",
            op_bitwise_not,
            1,
            1,
            1,
            "bitwise invert value A.",
        ),
        // Advanced arithmetic operations
        OpSpec::both_modes(
            OP_MULW,
            "mulw",
            op_mulw,
            1,
            10,
            1,
            "Multiply with overflow - returns low and high words.",
        ),
        OpSpec::both_modes(
            OP_ADDW,
            "addw",
            op_addw,
            2,
            10,
            1,
            "Add with overflow - returns low and high words.",
        ),
        OpSpec::both_modes(
            OP_DIVMODW,
            "divmodw",
            op_divmodw,
            4,
            20,
            1,
            "Division with remainder - returns quotient high, low, remainder.",
        ),
        OpSpec::both_modes(OP_SHL, "shl", op_shl, 4, 1, 1, "Shift left."),
        OpSpec::both_modes(OP_SHR, "shr", op_shr, 4, 1, 1, "Shift right."),
        OpSpec::both_modes(OP_SQRT, "sqrt", op_sqrt, 4, 4, 1, "Square root."),
        OpSpec::both_modes(OP_BITLEN, "bitlen", op_bitlen, 4, 1, 1, "Bit length."),
        OpSpec::both_modes(OP_EXP, "exp", op_exp, 4, 1, 1, "Exponentiation."),
        OpSpec::both_modes(
            OP_EXPW,
            "expw",
            op_expw,
            4,
            10,
            1,
            "Exponentiation with overflow.",
        ),
        OpSpec::both_modes(OP_BSQRT, "bsqrt", op_bsqrt, 6, 40, 1, "Byte square root."),
        OpSpec::both_modes(
            OP_DIVW,
            "divw",
            op_divw,
            6,
            20,
            1,
            "Division with overflow.",
        ),
        // Stack manipulation
        OpSpec::both_modes(
            OP_POP,
            "pop",
            op_pop,
            1,
            1,
            1,
            "Remove the top stack value.",
        ),
        OpSpec::both_modes(
            OP_POPN,
            "popn",
            op_popn,
            1,
            1,
            2,
            "Remove N values from stack.",
        ),
        OpSpec::both_modes(
            OP_DUPN,
            "dupn",
            op_dupn,
            1,
            1,
            2,
            "Duplicate Nth value from top.",
        ),
        OpSpec::both_modes(
            OP_DUP,
            "dup",
            op_dup,
            1,
            1,
            1,
            "Duplicate the top stack value.",
        ),
        OpSpec::both_modes(
            OP_DUP2,
            "dup2",
            op_dup2,
            2,
            1,
            1,
            "Duplicate top two stack values.",
        ),
        OpSpec::both_modes(
            OP_SWAP,
            "swap",
            op_swap,
            3,
            1,
            1,
            "Swap the top two stack values.",
        ),
        OpSpec::both_modes(
            OP_SELECT,
            "select",
            op_select,
            3,
            1,
            1,
            "Select between two values based on condition.",
        ),
        // Advanced stack operations
        OpSpec::both_modes(
            OP_BURY,
            "bury",
            op_bury,
            8,
            1,
            2,
            "Bury value n deep in stack.",
        ),
        OpSpec::both_modes(
            OP_DIG,
            "dig",
            op_dig,
            8,
            1,
            2,
            "Dig value n deep from stack.",
        ),
        OpSpec::both_modes(
            OP_COVER,
            "cover",
            op_cover,
            8,
            1,
            2,
            "Cover top value with n values.",
        ),
        OpSpec::both_modes(
            OP_UNCOVER,
            "uncover",
            op_uncover,
            8,
            1,
            2,
            "Uncover value from n deep.",
        ),
        // Flow control
        OpSpec::both_modes(OP_BNZ, "bnz", op_bnz, 1, 1, 3, "Branch if not zero."),
        OpSpec::both_modes(OP_BZ, "bz", op_bz, 2, 1, 3, "Branch if zero."),
        OpSpec::both_modes(OP_B, "b", op_b, 2, 1, 3, "Unconditional branch."),
        OpSpec::both_modes(
            OP_RETURN,
            "return",
            op_return,
            2,
            1,
            1,
            "Return from program.",
        ),
        OpSpec::both_modes(
            OP_ASSERT,
            "assert",
            op_assert,
            3,
            1,
            1,
            "Assert that A is not zero.",
        ),
        OpSpec::both_modes(
            OP_CALLSUB,
            "callsub",
            op_callsub,
            4,
            1,
            3,
            "Call subroutine.",
        ),
        OpSpec::both_modes(
            OP_RETSUB,
            "retsub",
            op_retsub,
            4,
            1,
            1,
            "Return from subroutine.",
        ),
        // Function control operations
        OpSpec::both_modes(
            OP_PROTO,
            "proto",
            op_proto,
            8,
            1,
            3,
            "Function prototype declaration.",
        ),
        OpSpec::both_modes(
            OP_FRAME_DIG,
            "frame_dig",
            op_frame_dig,
            8,
            1,
            2,
            "Access value from function frame.",
        ),
        OpSpec::both_modes(
            OP_FRAME_BURY,
            "frame_bury",
            op_frame_bury,
            8,
            1,
            2,
            "Store value in function frame.",
        ),
        OpSpec::both_modes(
            OP_SWITCH,
            "switch",
            op_switch,
            8,
            1,
            1,
            "Switch statement - jump to one of many targets.",
        ),
        OpSpec::both_modes(
            OP_MATCH,
            "match",
            op_match,
            8,
            1,
            1,
            "Match statement - matches specific values.",
        ),
        // Crypto
        OpSpec::both_modes(OP_SHA256, "sha256", op_sha256, 1, 35, 1, "SHA256 hash."),
        OpSpec::both_modes(
            OP_KECCAK256,
            "keccak256",
            op_keccak256,
            1,
            130,
            1,
            "Keccak256 hash.",
        ),
        OpSpec::both_modes(
            OP_SHA512_256,
            "sha512_256",
            op_sha512_256,
            1,
            45,
            1,
            "SHA512_256 hash.",
        ),
        OpSpec::both_modes(
            OP_SHA3_256,
            "sha3_256",
            op_sha3_256,
            1,
            45,
            1,
            "SHA3_256 hash.",
        ),
        OpSpec::both_modes(
            OP_ED25519VERIFY,
            "ed25519verify",
            op_ed25519verify,
            1,
            1900,
            1,
            "Ed25519 signature verification.",
        ),
        OpSpec::both_modes(
            OP_ED25519VERIFY_BARE,
            "ed25519verify_bare",
            op_ed25519verify_bare,
            1,
            1900,
            1,
            "Ed25519 bare signature verification.",
        ),
        OpSpec::both_modes(
            OP_ECDSA_VERIFY,
            "ecdsa_verify",
            op_ecdsa_verify,
            1,
            1700,
            1,
            "ECDSA signature verification.",
        ),
        OpSpec::both_modes(
            OP_ECDSA_PK_DECOMPRESS,
            "ecdsa_pk_decompress",
            op_ecdsa_pk_decompress,
            1,
            650,
            1,
            "ECDSA public key decompression.",
        ),
        OpSpec::both_modes(
            OP_ECDSA_PK_RECOVER,
            "ecdsa_pk_recover",
            op_ecdsa_pk_recover,
            1,
            2000,
            1,
            "ECDSA public key recovery.",
        ),
        // Constants
        OpSpec::both_modes(
            OP_PUSHINT,
            "pushint",
            op_pushint,
            1,
            1,
            9,
            "Push immediate integer.",
        ),
        OpSpec::both_modes(
            OP_PUSHBYTES,
            "pushbytes",
            op_pushbytes,
            1,
            1,
            1,
            "Push immediate bytes.",
        ),
        OpSpec::both_modes(
            OP_PUSHBYTESS,
            "pushbytess",
            op_pushbytess,
            1,
            1,
            1,
            "Push multiple immediate byte arrays.",
        ),
        OpSpec::both_modes(
            OP_PUSHINTS,
            "pushints",
            op_pushints,
            1,
            1,
            1,
            "Push multiple immediate integers.",
        ),
        // Constant blocks
        OpSpec::both_modes(
            OP_INTCBLOCK,
            "intcblock",
            op_intcblock,
            1,
            1,
            1,
            "Define integer constant block.",
        ),
        OpSpec::both_modes(
            OP_INTC,
            "intc",
            op_intc,
            1,
            1,
            2,
            "Load integer from constant block.",
        ),
        OpSpec::both_modes(
            OP_BYTECBLOCK,
            "bytecblock",
            op_bytecblock,
            1,
            1,
            1,
            "Define byte constant block.",
        ),
        OpSpec::both_modes(
            OP_BYTEC,
            "bytec",
            op_bytec,
            1,
            1,
            2,
            "Load bytes from constant block.",
        ),
        // Integer constants
        OpSpec::both_modes(
            OP_INTC_0,
            "intc_0",
            op_intc_0,
            1,
            1,
            1,
            "Push integer constant 0.",
        ),
        OpSpec::both_modes(
            OP_INTC_1,
            "intc_1",
            op_intc_1,
            1,
            1,
            1,
            "Push integer constant 1.",
        ),
        OpSpec::both_modes(
            OP_INTC_2,
            "intc_2",
            op_intc_2,
            1,
            1,
            1,
            "Push integer constant 2.",
        ),
        OpSpec::both_modes(
            OP_INTC_3,
            "intc_3",
            op_intc_3,
            1,
            1,
            1,
            "Push integer constant 3.",
        ),
        // Byte constants
        OpSpec::both_modes(
            OP_BYTEC_0,
            "bytec_0",
            op_bytec_0,
            1,
            1,
            1,
            "Push byte constant 0.",
        ),
        OpSpec::both_modes(
            OP_BYTEC_1,
            "bytec_1",
            op_bytec_1,
            1,
            1,
            1,
            "Push byte constant 1.",
        ),
        OpSpec::both_modes(
            OP_BYTEC_2,
            "bytec_2",
            op_bytec_2,
            1,
            1,
            1,
            "Push byte constant 2.",
        ),
        OpSpec::both_modes(
            OP_BYTEC_3,
            "bytec_3",
            op_bytec_3,
            1,
            1,
            1,
            "Push byte constant 3.",
        ),
        // Utility
        OpSpec::both_modes(OP_LEN, "len", op_len, 1, 1, 1, "Length of byte string."),
        OpSpec::both_modes(
            OP_ITOB,
            "itob",
            op_itob,
            1,
            1,
            1,
            "Convert integer to bytes.",
        ),
        OpSpec::both_modes(
            OP_BTOI,
            "btoi",
            op_btoi,
            1,
            1,
            1,
            "Convert bytes to integer.",
        ),
        OpSpec::both_modes(
            OP_CONCAT,
            "concat",
            op_concat,
            2,
            1,
            1,
            "Concatenate two byte strings.",
        ),
        OpSpec::both_modes(
            OP_SUBSTRING,
            "substring",
            op_substring,
            2,
            1,
            3,
            "Extract substring.",
        ),
        OpSpec::both_modes(
            OP_SUBSTRING3,
            "substring3",
            op_substring3,
            2,
            1,
            1,
            "Extract substring with stack args.",
        ),
        OpSpec::both_modes(
            OP_BZERO,
            "bzero",
            op_bzero,
            1,
            1,
            1,
            "Create zero-filled byte array.",
        ),
        // Byte math operations
        OpSpec::both_modes(OP_B_PLUS, "b+", op_b_plus, 4, 10, 1, "Byte addition."),
        OpSpec::both_modes(OP_B_MINUS, "b-", op_b_minus, 4, 10, 1, "Byte subtraction."),
        OpSpec::both_modes(OP_B_DIV, "b/", op_b_div, 4, 20, 1, "Byte division."),
        OpSpec::both_modes(OP_B_MUL, "b*", op_b_mul, 4, 20, 1, "Byte multiplication."),
        OpSpec::both_modes(OP_B_LT, "b<", op_b_lt, 4, 1, 1, "Byte less than."),
        OpSpec::both_modes(OP_B_GT, "b>", op_b_gt, 4, 1, 1, "Byte greater than."),
        OpSpec::both_modes(OP_B_LE, "b<=", op_b_le, 4, 1, 1, "Byte less than or equal."),
        OpSpec::both_modes(
            OP_B_GE,
            "b>=",
            op_b_ge,
            4,
            1,
            1,
            "Byte greater than or equal.",
        ),
        OpSpec::both_modes(OP_B_EQ, "b==", op_b_eq, 4, 1, 1, "Byte equal."),
        OpSpec::both_modes(OP_B_NE, "b!=", op_b_ne, 4, 1, 1, "Byte not equal."),
        OpSpec::both_modes(OP_B_MOD, "b%", op_b_mod, 4, 20, 1, "Byte modulo."),
        OpSpec::both_modes(OP_B_OR, "b|", op_b_or, 4, 6, 1, "Byte bitwise OR."),
        OpSpec::both_modes(OP_B_AND, "b&", op_b_and, 4, 6, 1, "Byte bitwise AND."),
        OpSpec::both_modes(OP_B_XOR, "b^", op_b_xor, 4, 6, 1, "Byte bitwise XOR."),
        OpSpec::both_modes(OP_B_NOT, "b~", op_b_not, 4, 4, 1, "Byte bitwise NOT."),
        // Byte manipulation operations
        OpSpec::both_modes(
            OP_GETBIT,
            "getbit",
            op_getbit,
            3,
            1,
            1,
            "Get bit from bytes.",
        ),
        OpSpec::both_modes(OP_SETBIT, "setbit", op_setbit, 3, 1, 1, "Set bit in bytes."),
        OpSpec::both_modes(
            OP_GETBYTE,
            "getbyte",
            op_getbyte,
            3,
            1,
            1,
            "Get byte from bytes.",
        ),
        OpSpec::both_modes(
            OP_SETBYTE,
            "setbyte",
            op_setbyte,
            3,
            1,
            1,
            "Set byte in bytes.",
        ),
        OpSpec::both_modes(
            OP_EXTRACT,
            "extract",
            op_extract,
            5,
            1,
            3,
            "Extract bytes with immediate start and length.",
        ),
        OpSpec::both_modes(
            OP_EXTRACT3,
            "extract3",
            op_extract3,
            5,
            1,
            1,
            "Extract bytes with stack arguments.",
        ),
        OpSpec::both_modes(
            OP_EXTRACT_UINT16,
            "extract_uint16",
            op_extract_uint16,
            5,
            1,
            1,
            "Extract uint16 from bytes.",
        ),
        OpSpec::both_modes(
            OP_EXTRACT_UINT32,
            "extract_uint32",
            op_extract_uint32,
            5,
            1,
            1,
            "Extract uint32 from bytes.",
        ),
        OpSpec::both_modes(
            OP_EXTRACT_UINT64,
            "extract_uint64",
            op_extract_uint64,
            5,
            1,
            1,
            "Extract uint64 from bytes.",
        ),
        OpSpec::both_modes(
            OP_REPLACE2,
            "replace2",
            op_replace2,
            7,
            1,
            2,
            "Replace bytes with immediate start.",
        ),
        OpSpec::both_modes(
            OP_REPLACE3,
            "replace3",
            op_replace3,
            7,
            1,
            1,
            "Replace bytes with stack arguments.",
        ),
        OpSpec::both_modes(
            OP_BASE64_DECODE,
            "base64_decode",
            op_base64_decode,
            7,
            1,
            2,
            "Base64 decode.",
        ),
        OpSpec::both_modes(
            OP_JSON_REF,
            "json_ref",
            op_json_ref,
            7,
            25,
            2,
            "JSON reference.",
        ),
        // Argument access
        OpSpec::both_modes(
            OP_ARG,
            "arg",
            op_arg,
            2,
            1,
            2,
            "Access argument with immediate index.",
        ),
        OpSpec::both_modes(OP_ARG_0, "arg_0", op_arg_0, 2, 1, 1, "Access argument 0."),
        OpSpec::both_modes(OP_ARG_1, "arg_1", op_arg_1, 2, 1, 1, "Access argument 1."),
        OpSpec::both_modes(OP_ARG_2, "arg_2", op_arg_2, 2, 1, 1, "Access argument 2."),
        OpSpec::both_modes(OP_ARG_3, "arg_3", op_arg_3, 2, 1, 1, "Access argument 3."),
        OpSpec::both_modes(
            OP_ARGS,
            "args",
            op_args,
            5,
            1,
            1,
            "Access arguments with stack index.",
        ),
        // Scratch space
        OpSpec::both_modes(
            OP_LOAD,
            "load",
            op_load,
            1,
            1,
            2,
            "Load from scratch space.",
        ),
        OpSpec::both_modes(
            OP_STORE,
            "store",
            op_store,
            1,
            1,
            2,
            "Store to scratch space.",
        ),
        // Transaction fields (signature mode)
        OpSpec::both_modes(OP_TXN, "txn", op_txn, 1, 1, 2, "Access transaction field."),
        OpSpec::both_modes(
            OP_GTXN,
            "gtxn",
            op_gtxn,
            1,
            1,
            3,
            "Access group transaction field.",
        ),
        OpSpec::both_modes(
            OP_GLOBAL,
            "global",
            op_global,
            1,
            1,
            2,
            "Access global field.",
        ),
        OpSpec::both_modes(
            OP_TXNA,
            "txna",
            op_txna,
            1,
            1,
            3,
            "Access transaction field array.",
        ),
        OpSpec::both_modes(
            OP_GTXNSA,
            "gtxnsa",
            op_gtxnsa,
            1,
            1,
            4,
            "Access group transaction field array with stack indices.",
        ),
        OpSpec::both_modes(
            OP_TXNAS,
            "txnas",
            op_txnas,
            1,
            1,
            2,
            "Access transaction field array with stack index.",
        ),
        // Application state (application mode only)
        OpSpec::app_only(
            OP_APP_GLOBAL_GET,
            "app_global_get",
            op_app_global_get,
            2,
            1,
            1,
            "Get global state.",
        ),
        OpSpec::app_only(
            OP_APP_GLOBAL_PUT,
            "app_global_put",
            op_app_global_put,
            2,
            1,
            1,
            "Put global state.",
        ),
        OpSpec::app_only(
            OP_APP_GLOBAL_DEL,
            "app_global_del",
            op_app_global_del,
            2,
            1,
            1,
            "Delete global state.",
        ),
        OpSpec::app_only(
            OP_APP_LOCAL_GET,
            "app_local_get",
            op_app_local_get,
            2,
            1,
            1,
            "Get local state.",
        ),
        OpSpec::app_only(
            OP_APP_LOCAL_PUT,
            "app_local_put",
            op_app_local_put,
            2,
            1,
            1,
            "Put local state.",
        ),
        OpSpec::app_only(
            OP_APP_LOCAL_DEL,
            "app_local_del",
            op_app_local_del,
            2,
            1,
            1,
            "Delete local state.",
        ),
        OpSpec::app_only(
            OP_BALANCE,
            "balance",
            op_balance,
            2,
            1,
            1,
            "Get account balance.",
        ),
        OpSpec::app_only(
            OP_MIN_BALANCE,
            "min_balance",
            op_min_balance,
            3,
            1,
            1,
            "Get minimum balance.",
        ),
        // Critical missing state opcodes
        OpSpec::app_only(
            OP_APP_OPTED_IN,
            "app_opted_in",
            op_app_opted_in,
            2,
            1,
            1,
            "Check if account is opted into application.",
        ),
        OpSpec::app_only(
            OP_APP_LOCAL_GET_EX,
            "app_local_get_ex",
            op_app_local_get_ex,
            2,
            1,
            1,
            "Get local state (extended).",
        ),
        OpSpec::app_only(
            OP_APP_GLOBAL_GET_EX,
            "app_global_get_ex",
            op_app_global_get_ex,
            2,
            1,
            1,
            "Get global state (extended).",
        ),
        OpSpec::app_only(
            OP_ASSET_HOLDING_GET,
            "asset_holding_get",
            op_asset_holding_get,
            2,
            1,
            2,
            "Get asset holding information.",
        ),
        OpSpec::app_only(
            OP_ASSET_PARAMS_GET,
            "asset_params_get",
            op_asset_params_get,
            2,
            1,
            2,
            "Get asset parameters.",
        ),
        OpSpec::app_only(
            OP_APP_PARAMS_GET,
            "app_params_get",
            op_app_params_get,
            2,
            1,
            2,
            "Get application parameters.",
        ),
        OpSpec::app_only(
            OP_ACCT_PARAMS_GET,
            "acct_params_get",
            op_acct_params_get,
            2,
            1,
            2,
            "Get account parameters.",
        ),
        OpSpec::both_modes(
            OP_GTXNA,
            "gtxna",
            op_gtxna,
            2,
            1,
            4,
            "Access group transaction field array.",
        ),
        OpSpec::both_modes(
            OP_GTXNS,
            "gtxns",
            op_gtxns,
            3,
            1,
            2,
            "Access group transaction field with stack index.",
        ),
        // Inner transaction operations
        OpSpec::app_only(
            OP_LOG,
            "log",
            op_log,
            5,
            1,
            1,
            "Log event (application mode only).",
        ),
        OpSpec::app_only(
            OP_ITXN_BEGIN,
            "itxn_begin",
            op_itxn_begin,
            5,
            1,
            1,
            "Begin construction of an inner transaction.",
        ),
        OpSpec::app_only(
            OP_ITXN_FIELD,
            "itxn_field",
            op_itxn_field,
            5,
            1,
            2,
            "Set field for current inner transaction.",
        ),
        OpSpec::app_only(
            OP_ITXN_SUBMIT,
            "itxn_submit",
            op_itxn_submit,
            5,
            1,
            1,
            "Submit current inner transaction.",
        ),
        OpSpec::app_only(
            OP_ITXN,
            "itxn",
            op_itxn,
            5,
            1,
            2,
            "Access field from last submitted inner transaction.",
        ),
        OpSpec::app_only(
            OP_ITXNA,
            "itxna",
            op_itxna,
            5,
            1,
            3,
            "Access array field from last submitted inner transaction.",
        ),
        OpSpec::app_only(
            OP_ITXN_NEXT,
            "itxn_next",
            op_itxn_next,
            6,
            1,
            1,
            "Begin construction of next inner transaction in group.",
        ),
        OpSpec::app_only(
            OP_GITXN,
            "gitxn",
            op_gitxn,
            6,
            1,
            3,
            "Access field from specific inner transaction in group.",
        ),
        OpSpec::app_only(
            OP_GITXNA,
            "gitxna",
            op_gitxna,
            6,
            1,
            4,
            "Access array field from specific inner transaction in group.",
        ),
        OpSpec::app_only(
            OP_ITXNAS,
            "itxnas",
            op_itxnas,
            6,
            1,
            2,
            "Access array field from last submitted inner transaction (stack index).",
        ),
        OpSpec::app_only(
            OP_GITXNAS,
            "gitxnas",
            op_gitxnas,
            6,
            1,
            3,
            "Access array field from specific inner transaction in group (stack index).",
        ),
        // Box storage operations
        OpSpec::app_only(
            OP_BOX_CREATE,
            "box_create",
            op_box_create,
            8,
            400,
            1,
            "Create a new box with the given name and size.",
        ),
        OpSpec::app_only(
            OP_BOX_EXTRACT,
            "box_extract",
            op_box_extract,
            8,
            40,
            1,
            "Extract bytes from a box.",
        ),
        OpSpec::app_only(
            OP_BOX_REPLACE,
            "box_replace",
            op_box_replace,
            8,
            40,
            1,
            "Replace bytes in a box.",
        ),
        OpSpec::app_only(OP_BOX_DEL, "box_del", op_box_del, 8, 40, 1, "Delete a box."),
        OpSpec::app_only(
            OP_BOX_LEN,
            "box_len",
            op_box_len,
            8,
            40,
            1,
            "Get the length of a box.",
        ),
        OpSpec::app_only(
            OP_BOX_GET,
            "box_get",
            op_box_get,
            8,
            40,
            1,
            "Get the entire contents of a box.",
        ),
        OpSpec::app_only(
            OP_BOX_PUT,
            "box_put",
            op_box_put,
            8,
            40,
            1,
            "Put bytes into a box (overwrite entire contents).",
        ),
        OpSpec::app_only(
            OP_BOX_SPLICE,
            "box_splice",
            op_box_splice,
            9,
            40,
            1,
            "Splice bytes into a box (insert/replace with size change).",
        ),
        OpSpec::app_only(
            OP_BOX_RESIZE,
            "box_resize",
            op_box_resize,
            9,
            40,
            1,
            "Resize a box.",
        ),
        // Elliptic curve operations
        OpSpec::app_only(
            OP_EC_ADD,
            "ec_add",
            op_ec_add,
            10,
            100,
            2,
            "Add two points on an elliptic curve.",
        ),
        OpSpec::app_only(
            OP_EC_SCALAR_MUL,
            "ec_scalar_mul",
            op_ec_scalar_mul,
            10,
            1000,
            2,
            "Multiply a point by a scalar on an elliptic curve.",
        ),
        OpSpec::app_only(
            OP_EC_PAIRING_CHECK,
            "ec_pairing_check",
            op_ec_pairing_check,
            10,
            8000,
            2,
            "Check if pairing equation holds for given points.",
        ),
        OpSpec::app_only(
            OP_EC_MULTI_SCALAR_MUL,
            "ec_multi_scalar_mul",
            op_ec_multi_scalar_mul,
            10,
            3000,
            2,
            "Multi-scalar multiplication on elliptic curves.",
        ),
        OpSpec::app_only(
            OP_EC_SUBGROUP_CHECK,
            "ec_subgroup_check",
            op_ec_subgroup_check,
            10,
            500,
            2,
            "Check if a point is in the correct subgroup.",
        ),
        OpSpec::app_only(
            OP_EC_MAP_TO,
            "ec_map_to",
            op_ec_map_to,
            10,
            200,
            2,
            "Map field element to curve point.",
        ),
        // Advanced cryptography operations
        OpSpec::app_only(
            OP_VRF_VERIFY,
            "vrf_verify",
            op_vrf_verify,
            7,
            5700,
            1,
            "Verify a VRF proof and return the VRF output.",
        ),
        OpSpec::app_only(
            OP_MIMC,
            "mimc",
            op_mimc,
            11,
            100,
            2,
            "Advanced cryptographic hash function (MiMC).",
        ),
        OpSpec::app_only(
            OP_BLOCK,
            "block",
            op_block,
            11,
            1,
            2,
            "Get random bytes from blockchain randomness beacon.",
        ),
    ]
}
